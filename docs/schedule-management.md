# Управление расписанием

## Обзор

Система управления расписанием позволяет мастерам создавать и управлять временными окнами для приема клиентов. Система автоматически учитывает занятые окна и блокирует соседние часы при длительных заказах.

## Основные функции

### 1. Создание временных окон
- Мастера могут создавать временные окна на конкретные даты
- **Фиксированные часовые окна**: Система использует стандартные часовые интервалы (09:00-10:00, 10:00-11:00, 11:00-12:00 и т.д.)
- Поддерживается множественный выбор дат для массового создания
- Можно указать статус окна (свободно/заблокировано)
- Добавление заметок к временным окнам

### 2. Учет занятых окон
- **Автоматическое скрытие**: Окна с подтвержденными заказами автоматически скрываются из расписания
- **Блокировка соседних часов**: При длительности услуги более 60 минут соседние часовые окна также блокируются
- **Интеллектуальная фильтрация**: Система учитывает все подтвержденные и завершенные заказы
- **Фиксированные интервалы**: Окна не пересекаются, так как используются стандартные часовые интервалы

### 3. Шаблоны недели
- Создание шаблонов на основе существующего расписания
- Применение шаблонов на несколько недель вперед
- Удобное копирование расписания

## Техническая реализация

### Серверная часть

#### Контроллер расписания (`ScheduleController`)

**Методы с учетом занятых окон:**

1. `getMasterSchedule()` - Получение расписания мастера
2. `getMySchedule()` - Получение собственного расписания
3. `getAvailableSlots()` - Получение доступных слотов для бронирования

**Логика учета занятых окон:**

```typescript
// Получение заказов для определения занятых окон
const orders = await orderRepository.find({
    where: [
        { nailMaster: { id: masterId }, status: OrderStatus.CONFIRMED },
        { nailMaster: { id: masterId }, status: OrderStatus.COMPLETED }
    ],
    relations: ['masterService']
});

// Создание карты занятых окон
const occupiedSlots = new Map<string, Set<string>>();

orders.forEach(order => {
    if (order.confirmedDateTime) {
        const orderDate = order.confirmedDateTime.toISOString().split('T')[0];
        const orderTime = order.confirmedDateTime.toTimeString().substring(0, 5);
        
        // Добавление основного времени заказа
        timeSlots.add(orderTime);
        
        // Блокировка соседних часов при длительности > 60 минут
        if (order.masterService && order.masterService.duration > 60) {
            const totalHours = Math.ceil(order.masterService.duration / 60);
            
            for (let hour = 1; hour < totalHours; hour++) {
                const nextHour = (startHour + hour) % 24;
                const nextTime = `${nextHour.toString().padStart(2, '0')}:${startMinute.toString().padStart(2, '0')}`;
                timeSlots.add(nextTime);
            }
        }
    }
});
```

**Логика проверки пересечений для фиксированных окон:**

```typescript
// Проверяем только точное совпадение временных окон
// Не проверяем пересечения, так как окна должны быть независимыми
// Например: 09:00-10:00 и 10:00-11:00 не должны конфликтовать
for (const slot of conflictingSlots) {
    if (newStart === existingStart && newEnd === existingEnd) {
        ResponseUtil.error(res, `Временное окно с таким же временем уже существует`, 409);
        return;
    }
}
```

### Клиентская часть

#### Компонент `ScheduleManager`

**Новые функции:**

1. **Фиксированные часовые окна** - Пользователь выбирает из предопределенных часовых интервалов
2. **Информационное уведомление** - Пользователь видит объяснение логики работы системы
3. **Улучшенные сообщения** - Более понятные сообщения о занятых окнах
4. **Автоматическое обновление** - Расписание обновляется с учетом занятых окон

**Ключевые изменения:**

```typescript
// Функция для получения фиксированных часовых окон
const getHourlySlots = () => {
  const slots = [];
  for (let hour = 8; hour <= 21; hour++) {
    const startTime = `${hour.toString().padStart(2, '0')}:00`;
    const endTime = `${(hour + 1).toString().padStart(2, '0')}:00`;
    slots.push({ startTime, endTime, label: `${startTime} - ${endTime}` });
  }
  return slots;
};

// Информационное уведомление
<div className="bg-blue-50 dark:bg-blue-950 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4">
  <div className="flex items-start gap-3">
    <AlertCircle className="w-5 h-5 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" />
    <div className="text-sm text-blue-800 dark:text-blue-200">
      <p className="font-medium mb-1">Информация о расписании</p>
      <p>Система использует фиксированные часовые окна (09:00-10:00, 10:00-11:00 и т.д.). Занятые окна (подтвержденные заказы) автоматически скрываются из расписания. При длительности услуги более 60 минут соседние часовые окна также блокируются.</p>
    </div>
  </div>
</div>
```

## Алгоритм блокировки соседних окон

### Условия блокировки:
1. Заказ имеет статус `CONFIRMED` или `COMPLETED`
2. Длительность услуги больше 60 минут
3. Есть подтвержденное время заказа (`confirmedDateTime`)

### Логика расчета:
1. Определяется время начала заказа
2. Вычисляется количество часов: `Math.ceil(duration / 60)`
3. Блокируются все последующие часовые окна

**Пример:**
- Заказ на 14:00 с длительностью 90 минут
- Блокируются окна: 14:00-15:00, 15:00-16:00
- Заказ на 10:00 с длительностью 120 минут  
- Блокируются окна: 10:00-11:00, 11:00-12:00, 12:00-13:00

## Фиксированные часовые окна

### Доступные интервалы:
- 08:00-09:00
- 09:00-10:00
- 10:00-11:00
- 11:00-12:00
- 12:00-13:00
- 13:00-14:00
- 14:00-15:00
- 15:00-16:00
- 16:00-17:00
- 17:00-18:00
- 18:00-19:00
- 19:00-20:00
- 20:00-21:00
- 21:00-22:00

### Преимущества фиксированных окон:
1. **Отсутствие конфликтов** - Окна не пересекаются
2. **Простота планирования** - Стандартные часовые интервалы
3. **Удобство для клиентов** - Понятные временные слоты
4. **Автоматическая блокировка** - Система сама блокирует соседние часы

## API Endpoints

### Получение расписания
```
GET /api/masters/:masterId/schedule
GET /api/masters/schedule (для текущего мастера)
```

**Параметры:**
- `startDate` (опционально) - Начальная дата
- `endDate` (опционально) - Конечная дата

**Ответ:**
```json
{
  "success": true,
  "data": [
    {
      "date": "2024-01-15",
      "timeSlots": [
        {
          "id": "uuid",
          "startTime": "09:00",
          "endTime": "10:00",
          "status": "available",
          "notes": "Свободное окно"
        }
      ]
    }
  ]
}
```

### Получение доступных слотов
```
GET /api/masters/:masterId/schedule/available
```

**Параметры:**
- `date` (обязательно) - Дата для поиска

**Ответ:**
```json
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "startTime": "09:00",
      "endTime": "10:00",
      "status": "available"
    }
  ]
}
```

## Интеграция с системой заказов

### Связь с заказами:
- Расписание учитывает только подтвержденные и завершенные заказы
- Время заказа берется из поля `confirmedDateTime`
- Длительность услуги берется из связанной `MasterServiceEntity`

### Автоматическое обновление:
- При изменении статуса заказа расписание автоматически обновляется
- При изменении времени заказа пересчитываются занятые окна
- При изменении длительности услуги пересчитываются блокировки

## Рекомендации по использованию

### Для мастеров:
1. Регулярно проверяйте расписание на предмет занятых окон
2. Используйте шаблоны недели для планирования
3. Добавляйте заметки к временным окнам для лучшей организации
4. Помните о фиксированных часовых окнах при планировании

### Для разработчиков:
1. При создании заказов учитывайте автоматическую блокировку
2. Тестируйте логику с различными длительностями услуг
3. Мониторьте производительность при большом количестве заказов
4. Учитывайте фиксированные часовые окна при разработке новых функций

## Будущие улучшения

1. **Визуализация занятых окон** - Показ заблокированных слотов с пояснениями
2. **Гибкие временные окна** - Поддержка нестандартных интервалов (опционально)
3. **Уведомления** - Автоматические уведомления о конфликтах расписания
4. **Аналитика** - Статистика использования временных окон 